#!/usr/bin/env bash
### .functions - more complicated aliases, basically

# colors
_RED="$(tty -s && tput setaf 1)"
_YELLOW="$(tty -s && tput setaf 3)"
_WHITE="$(tty -s && tput setaf 7)"
_GRAY="$(tty -s && tput setaf 8)"
_BOLD="$(tty -s && tput bold)"
_RESET="$(tty -s && tput sgr0)"

# list: display all functions in custom dotfiles
function _funclist {
  if hash ag 2>/dev/null; then
    ag '(function )([A-Za-z0-9_-]+)' "$HOME"/.functions* --nonumbers
  else
    echo 'Error: Missing ag (silver searcher). Cannot display functions.'
  fi
}

function _anon() {
  read -r str
  pattern="\/Users\/$USER|\/home\/$USER"

  if [[ $str =~ $pattern ]]; then
    # -E argument is required for regex
    echo "$str" | sed -E "s/$pattern/\$HOME/"
  else
    echo "$str"
  fi
}

# ansicolors: display all fg and bg ansi color escape codes
function ansicolors {
  for attr in $(seq 0 1); do
    for fg in $(seq 30 37); do
      for bg in $(seq 40 47); do
        printf "\033[%i;%i;%im%i;$i;%i\033[m " "$attr" "$bg" "$fg" "$attr" "$fg" "$bg"
      done
      echo
    done
  done
}

# b64: base64 encode string
function b64 {
  echo -n "$1" | openssl base64
}

# countdown: start a full-screen countdown
function countdown() {
  start=${1:60}
  now=$(date +%s)
  watch -tn1 echo "$((now-$(date +%s)+start))"
}

# df_low: email admin if disk free space is low
function df_low() {
  OS=$(uname)

  if [ "$OS" = "Darwin" ]; then
    ROOT="/System/Volumes/Data"
  else
    ROOT="/"
  fi

  CURRENT=$(df $ROOT | grep $ROOT | awk '{ print $5}' | sed 's/%//g')
  THRESHOLD=90
  USER=neb
  DOMAIN=neb.host

  if [ "$CURRENT" -gt "$THRESHOLD" ] ; then
    msg="Root partition free space on $HOSTNAME is critically low. Used: $CURRENT%"
    echo "$msg" | mail -s "Disk Space Alert for $HOSTNAME" $USER@$DOMAIN
  fi
}

# color show in your terminal
# source: https://twitter.com/climagic/status/817405740772184065
function display_colors {
  yes "$(seq 16 231)" | while read -r i;
  do printf "\x1b[48;5;%im\n" "$i";
  sleep .02;
  done
}

# make it snow in your terminal
# source: http://climagic.org/coolstuff/let-it-snow.html
function display_snow {
  export LINES COLUMNS;
  clear;
  while :;
  do echo $LINES $COLUMNS $((RANDOM % COLUMNS));
  sleep 0.1;
  done|gawk '{a[$3]=0;for(x in a) {o=a[x];a[x]=a[x]+1;printf "\033[%s;%sH ",o,x; printf "\033[%s;%sH*\033[0;0H",a[x],x;}}'
}

# dummy: create dummy binary file
function dummy() {
  dd if=/dev/urandom bs=1024 count="$1" of=dummy
}

# print out list of generic variables
function foobarlist() {
  list=('foo' 'bar' 'baz' 'qux' 'quux' 'quuz' 'corge' 'grault' 'garply' 'waldo' 'fred' 'plugh' 'xyzzy' 'thud')

  if [ $# -eq 0 ]; then
    for w in "${list[@]}"; do
      echo "$w"
    done
  elif [ $# -ge 1 ]; then
    echo "${list[$1]}"
  fi
}

# get_rand_port: get random available local port for local webservers
function get_rand_port {
  netstat -aln | awk '
    $6 == "LISTEN" {
      if ($4 ~ "[.:][0-9]+$") {
        split($4, a, /[:.]/);
        port = a[length(a)];
        p[port] = 1
      }
    }
    END {
      for (i = 3000; i < 65000 && p[i]; i++){};
      if (i == 65000) {exit 1};
      print i
    }
  '
}

function histleast {
  if [ $# -eq 1 ]; then
    count=$1
  else
    count=10
  fi

  history | awk '{CMD[$4]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | tail -n$count
}
function histmost {
  if [ $# -eq 1 ]; then
    count=$1
  else
    count=10
  fi

  history | awk '{CMD[$4]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n$count
}

# list http ports and procs
function httports {
  # shellcheck disable=SC2196
  lsof -i -n -P | grep "$HTTP_SERVICES" | grep LISTEN | egrep -o ":[0-9]{2,5}" | cut -f2- -d: | sort -n | uniq
}
function httportss {
  # shellcheck disable=SC2196
  sudo lsof -i -n -P | grep "$HTTP_SERVICES" | grep LISTEN | egrep -o ":[0-9]{2,5}" | cut -f2- -d: | sort -n | uniq
}
function httprocs() {
  lsof -i -n -P | grep 'httpd\|vpnkit\|java\|nc\|node\|ng' | grep LISTEN | awk '{print $1}' | sort -n
}
function httprocss {
  sudo lsof -i -n -P | grep 'httpd\|vpnkit\|java\|nc\|node\|ng' | grep LISTEN | awk '{print $1}' | sort -n | uniq
}

# simple http servers for local directory in various flavors
## php
function httphp {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  php -S 127.0.0.1:"$rport";
}
## python 2.x
function httpy2 {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  python -m SimpleHTTPServer "$rport";
}
## python 3.x
function httpy3 {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  python3 -m http.server "$rport";
}
## python 3.x (or 2.x if 3.x not available)
function httpy {
  if hash python3 2>/dev/null; then
    httpy3
  else
    httpy2
  fi
}
## nodejs (http-server)
function httnode {
  rport=$(get_rand_port);
  http-server -o -p "$rport";
}
## ruby 1.9.2+
function httruby {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  ruby -run -e httpd . -p "$rport";
}

## get the Notes field from a Logic Pro X project (e.g. lyrics)
function lpxnotes_dump() {
  # Check if a filename is provided as an argument
  if [ "$#" -ne 1 ]; then
    echo "Usage: lpxnotes_dump <filename>"
  else
    # assuming only one Alternative
    filename=$1/Alternatives/000/ProjectData

    # Check if the file exists
    if [ ! -e "$filename" ]; then
      echo "File not found: $filename"
    else
      # regex pattern for code where Notes start and end (in LPX 10.7, at least)
      pattern='\\\\f0\\\\fs30'
      end_pattern='}'

      # find first, and only first, instance of this to capture Project Notes
      str=$(strings "$filename" | awk -v pattern="$pattern" -v end_pattern="$end_pattern" '
        $0 ~ pattern {
          flag=1
        }
        flag {
          print
        }
        $0 ~ end_pattern && flag {
          flag=0
          exit
        }
      ')

      # clean up output
      notes=$(
        echo "$str" \
        | awk '{gsub(/pard.+/,""); print}' \
        | awk '{gsub(/\\f0\\fs30/,""); print}' \
        | awk '{gsub(/\\cf2 /,""); print}' \
        | awk '{gsub(/^ /,""); print}' \
        | awk '{gsub(/\\/,""); print}' \
        | awk '{gsub(/\}/,""); print}' \
        | awk '{gsub(/^[\s]+$/,""); print}' \
        | awk '{gsub(/qSxT/,""); print}'
      )

      echo "$notes"
    fi
  fi
}

# display public IP using cloudflare/google
# myip 4 -> IPv4, myip 6 -> IPv6, myip -> IPv4 and IPv6
function myip() {
  if [ $# -eq 0 ]; then
    myip4=$(dig +short txt ch whoami.cloudflare @1.0.0.1)
    myip6=$(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com)

    echo "$myip4" | xargs
    echo "$myip6" | xargs
  elif [ $# -ge 1 ]; then
    if [ "$1" -eq '4' ]; then
      myip=$(dig +short txt ch whoami.cloudflare @1.0.0.1)

      echo "$myip" | xargs
    elif [ "$1" -eq '6' ]; then
      myip=$(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com)

      echo "$myip" | xargs
    else
      echo "only IPv4 and IPv6 supported"
    fi
  fi
}

# play rainymood music
function rainymood {
  FILE=$((RANDOM%4))
  URL="https://rainymood.com/audio1110/${FILE}.ogg"
  mpv "$URL" && rainymood
}

# roll a die
function roll() {
  if [ $# -ge 1 ]; then
    echo $((RANDOM % 1 + 1))
  else
    echo $((RANDOM % 2))
  fi
}

# speedtest
function speedtest() {
  if hash speedtest-cli 2>/dev/null; then
    logfile="$HOME"/Documents/speedtest_log.txt

    echo "Checking internet speed and logging..."
    {
      date
      echo "============================"
      hostname
      speedtest-cli --simple
      echo "----------------------------"
      echo ""
    } >> "$logfile"
    echo "Done and logged to $logfile"
  else
    echo "speedtest-cli not installed; try brew install speedtest-cli"
  fi
}

# homebrew updating
function steep {
  echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
  echo "${_BOLD}${_WHITE}| START: Homebrew update       |${_RESET}"
  echo "${_BOLD}${_WHITE}| brew update                  |${_RESET}"
  echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"

  if brew update; then
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    echo "${_BOLD}${_WHITE}| START: Homebrew upgrade      |${_RESET}"
    echo "${_BOLD}${_WHITE}| brew upgrade                 |${_RESET}"
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    brew upgrade
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    echo "${_BOLD}${_WHITE}| START: Homebrew upgrade cask |${_RESET}"
    echo "${_BOLD}${_WHITE}| brew update --cask           |${_RESET}"
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    brew upgrade --cask
  else
    echo "${_BOLD}${_WHITE}-------------------------------${_RESET}"
    echo "${_BOLD}${_RED}could not upgrade due to update error${_RESET}"
  fi
}

# mov to gif
function vid2gif() {
  RUN_CMD=true

  if ! [ -x "$(command -v ffmpeg)" ]; then
    echo 'Error: ffmpeg is not installed. Please install with (brew install ffmpeg)' >&2
    RUN_CMD=false
  fi

  if ! [ -x "$(command -v gifsicle)" ]; then
    echo 'Error: gifsicle is not installed. Please install with (brew install gifsicle)' >&2
    RUN_CMD=false
  fi

  if [ "$RUN_CMD" = true ]; then
    ffmpeg -i "$1" -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=8 > ~/Downloads/"$1".gif
  fi
}
alias mp42gif=vid2gif
alias mov2gif=vid2gif

# wav to flac
function wav2flac() {
  if ! [ -x "$(command -v ffmpeg)" ]; then
    echo 'Error: ffmpeg is not installed. please install with (brew install ffmpeg)' >&2
    exit 1
  fi

  for i in *.wav; do ffmpeg -i "$i" "${i%.*}.flac"; done
}

# wav to mp3
function wav2mp3() {
  if ! [ -x "$(command -v ffmpeg)" ]; then
    echo 'Error: ffmpeg is not installed. please install with (brew install ffmpeg)' >&2
    exit 1
  fi

  for i in *.wav; do ffmpeg -i "$i" "${i%.*}.mp3"; done
}

# * to *
function mediaconv() {
  if ! [ -x "$(command -v ffmpeg)" ]; then
    echo 'Error: ffmpeg is not installed. please install with (brew install ffmpeg)' >&2
    exit 1
  fi

  if [ "$#" -lt 2 ]; then
    echo "Usage: mediaconv <ext1> <ext2>"
  fi

  for i in *."$1"; do ffmpeg -i "$i" "${i%.*}.$2"; done
}

##############################################################

## load about() function
if [ -f "$HOME"/.functions_about ]; then source "$HOME"/.functions_about; fi

## load private, non-tracked, functions
# shellcheck source=/dev/null
if [ -f "$HOME"/.functions_priv ]; then source "$HOME"/.functions_priv; fi
