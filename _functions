#!/usr/bin/env bash
### .functions - more complicated aliases, basically

# colors
_RED="$(tput setaf 1)"
_YELLOW="$(tput setaf 3)"
_WHITE="$(tput setaf 7)"
_BOLD="$(tput bold)"
_RESET="$(tput sgr0)"

# list: display all functions in custom dotfiles
function _funclist {
  if hash ag 2>/dev/null; then
    ag '(function )([A-Za-z0-9_-]+)' "$HOME"/.functions* --nonumbers
  else
    echo 'Error: Missing ag (silver searcher). Cannot display functions.'
  fi
}

# about: display info about current system
function about {
  # OS info
  if hash neofetch 2>/dev/null; then
    neofetch
  else
    if hash archey 2>/dev/null; then
      archey -c "$1"
    else
      if [ -f /etc/redhat-release ]; then
        cat /etc/redhat-release
      else
        if [ -f /etc/os-release ]; then
          cat /etc/os-release
        else
          if [ -f /proc/version ]; then
            cat /proc/version
          else
            uname -a
          fi
        fi
      fi
    fi
  fi

  # programming versions
  if hash asdf 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}asdf${_RESET}:      ${_BOLD}${_WHITE}$(asdf version)${_RESET} $(which asdf)"
  else
    echo "asdf not installed"
  fi

  if hash go 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}go${_RESET}:      ${_BOLD}${_WHITE}$(go version)${_RESET} $(which go)"
  else
    echo "go not installed"
  fi

  if hash java 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}java${_RESET}:    ${_BOLD}${_WHITE}$(java -version 2>&1 | head -n 1)${_RESET} $(which java)"

    if hash jenv 2>/dev/null; then
      echo "${_BOLD}${_YELLOW}- jenv${_RESET}:    ${_BOLD}${_WHITE}$(jenv --version)${_RESET}; using: $(jenv global)"
    else
      echo "jenv not installed"
    fi
  else
    echo "java not installed"
  fi

  if hash node 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}node${_RESET}:    ${_BOLD}${_WHITE}$(node -v)${_RESET} $(which node)"
    echo "${_BOLD}${_YELLOW}- npm${_RESET}:   ${_BOLD}${_WHITE}$(npm -v)${_RESET} $(which npm)"
    echo "${_BOLD}${_YELLOW}- npx${_RESET}:   ${_BOLD}${_WHITE}$(npx -v)${_RESET} $(which npx)"

    if hash nvm 2>/dev/null; then
      echo "${_BOLD}${_YELLOW}- nvm${_RESET}:   ${_BOLD}${_WHITE}$(nvm --version)${_RESET} $(which nvm)"
    else
      echo "nvm not installed"
    fi
  else
    echo "node not installed"
  fi

  echo "${_BOLD}${_YELLOW}php${_RESET}:     ${_BOLD}${_WHITE}$(php -v | head -1)${_RESET} $(which php)"

  if hash python 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}python${_RESET}:  ${_BOLD}${_WHITE}$(python -c 'import sys; print(sys.version)' | head -1)${_RESET}$(which python)"
  else
    echo "python not installed"
  fi

  if hash python2 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}python2${_RESET}: ${_BOLD}${_WHITE}$(python -c 'import sys; print(sys.version)' | head -1)${_RESET}$(which python2)"
  else
    echo "python2 not installed"
  fi

  if hash python3 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}python3${_RESET}: ${_BOLD}${_WHITE}$(python3 --version)${_RESET} $(which python3)"
  else
    echo "python3 not installed"
  fi

  if hash pyenv 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}- pyenv${_RESET}  ${_BOLD}${_WHITE}$(pyenv -v)${_RESET}; using: $(pyenv global)"
  else
    echo "pyenv not installed"
  fi

  if hash ruby 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}ruby${_RESET}:    ${_BOLD}${_WHITE}$(ruby -v)${_RESET} $(which ruby)"
    echo "${_BOLD}${_YELLOW}- gem${_RESET}:   ${_BOLD}${_WHITE}$(gem -v)${_RESET} $(which gem)"

    if hash rbenv 2>/dev/null; then
      echo "${_BOLD}${_YELLOW}- rbenv${_RESET}  ${_BOLD}${_WHITE}$(rbenv -v)${_RESET}; using: $(rbenv global)"
    else
      echo "rbenv not installed"
    fi
  else
    echo "ruby not installed"
  fi

  if hash rustc 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}rust${_RESET}:    ${_BOLD}${_WHITE}$(rustc --version)${_RESET} $(which rustc)"
  else
    echo "rustc not installed"
  fi

  if hash tsc 2>/dev/null; then
    echo "${_BOLD}${_YELLOW}tsc${_RESET}:     ${_BOLD}${_WHITE}$(tsc -v | cut -d' ' -f2-)${_RESET} $(which tsc)"
  else
    echo "tsc not installed"
  fi
}

# ansicolors: display all fg and bg ansi color escape codes
function ansicolors {
  for attr in $(seq 0 1); do
    for fg in $(seq 30 37); do
      for bg in $(seq 40 47); do
        printf "\033[%i;%i;%im%i;$i;%i\033[m " "$attr" "$bg" "$fg" "$attr" "$fg" "$bg"
      done
      echo
    done
  done
}

# countdown: start a full-screen countdown
function countdown() {
  start=${1:60}
  now=$(date +%s)
  watch -tn1 echo "$((now-$(date +%s)+start))"
}

# color show in your terminal
# source: https://twitter.com/climagic/status/817405740772184065
function display_colors {
  yes "$(seq 16 231)" | while read -r i;
  do printf "\x1b[48;5;%im\n" "$i";
  sleep .02;
  done
}

# make it snow in your terminal
# source: http://climagic.org/coolstuff/let-it-snow.html
function display_snow {
  export LINES COLUMNS;
  clear;
  while :;
  do echo $LINES $COLUMNS $((RANDOM % COLUMNS));
  sleep 0.1;
  done|gawk '{a[$3]=0;for(x in a) {o=a[x];a[x]=a[x]+1;printf "\033[%s;%sH ",o,x; printf "\033[%s;%sH*\033[0;0H",a[x],x;}}'
}

# dummy: create dummy binary file
function dummy() {
  dd if=/dev/urandom bs=1024 count="$1" of=dummy
}

# print out list of generic variables
function foobarlist() {
  list=('foo' 'bar' 'baz' 'qux' 'quux' 'quuz' 'corge' 'grault' 'garply' 'waldo' 'fred' 'plugh' 'xyzzy' 'thud')

  if [ $# -eq 0 ]; then
    for w in "${list[@]}"; do
      echo "$w"
    done
  elif [ $# -ge 1 ]; then
    echo "${list[$1]}"
  fi
}

# get_rand_port: get random available local port for local webservers
function get_rand_port {
  netstat -aln | awk '
    $6 == "LISTEN" {
      if ($4 ~ "[.:][0-9]+$") {
        split($4, a, /[:.]/);
        port = a[length(a)];
        p[port] = 1
      }
    }
    END {
      for (i = 3000; i < 65000 && p[i]; i++){};
      if (i == 65000) {exit 1};
      print i
    }
  '
}

# list http ports and procs
function httports {
  # shellcheck disable=SC2196
  lsof -i -n -P | grep "$HTTP_SERVICES" | grep LISTEN | egrep -o ":[0-9]{2,5}" | cut -f2- -d: | sort -n | uniq
}
function httportss {
  # shellcheck disable=SC2196
  sudo lsof -i -n -P | grep "$HTTP_SERVICES" | grep LISTEN | egrep -o ":[0-9]{2,5}" | cut -f2- -d: | sort -n | uniq
}
function httprocs() {
  lsof -i -n -P | grep 'httpd\|vpnkit\|java\|nc\|node\|ng' | grep LISTEN | awk '{print \$1}' | sort -n
}
function httprocss {
  sudo lsof -i -n -P | grep 'httpd\|vpnkit\|java\|nc\|node\|ng' | grep LISTEN | awk '{print \$1}' | sort -n | uniq
}

# simple http servers for local directory in various flavors
## php
function httphp {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  php -S 127.0.0.1:"$rport";
}
## python 2.x
function httpy2 {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  python -m SimpleHTTPServer "$rport";
}
## python 3.x
function httpy3 {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  python3 -m http.server "$rport";
}
## nodejs (http-server)
function httnode {
  rport=$(get_rand_port);
  http-server -o -p "$rport";
}
## ruby 1.9.2+
function httruby {
  rport=$(get_rand_port);
  open http://localhost:"$rport";
  ruby -run -e httpd . -p "$rport";
}

# display public IP using cloudflare/google
# myip 4 -> IPv4, myip 6 -> IPv6, myip -> IPv4 and IPv6
function myip() {
  if [ $# -eq 0 ]; then
    myip4=$(dig +short txt ch whoami.cloudflare @1.0.0.1)
    myip6=$(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com)

    echo "$myip4" | xargs
    echo "$myip6" | xargs
  elif [ $# -ge 1 ]; then
    if [ "$1" -eq '4' ]; then
      myip=$(dig +short txt ch whoami.cloudflare @1.0.0.1)

      echo "$myip" | xargs
    elif [ "$1" -eq '6' ]; then
      myip=$(dig -6 TXT +short o-o.myaddr.l.google.com @ns1.google.com)

      echo "$myip" | xargs
    else
      echo "only IPv4 and IPv6 supported"
    fi
  fi
}

# play rainymood music
function rainymood {
  FILE=$((RANDOM%4))
  URL="https://rainymood.com/audio1110/${FILE}.ogg"
  mpv "$URL" && rainymood
}

# roll a die
function roll() {
  if [ $# -ge 1 ]; then
    echo $((RANDOM % 1 + 1))
  else
    echo $((RANDOM % 2))
  fi
}

# speedtest
function speedtest() {
  if hash speedtest-cli 2>/dev/null; then
    logfile="$HOME"/Documents/speedtest_log.txt

    echo "Checking internet speed and logging..."
    {
      date
      echo "============================"
      hostname
      speedtest-cli --simple
      echo "----------------------------"
      echo ""
    } >> "$logfile"
    echo "Done and logged to $logfile"
  else
    echo "speedtest-cli not installed; try brew install speedtest-cli"
  fi
}

# homebrew updating
function steep {
  echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
  echo "${_BOLD}${_WHITE}| START: Homebrew update       |${_RESET}"
  echo "${_BOLD}${_WHITE}| brew update                  |${_RESET}"
  echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
  brew update

  if [ $? -eq 0 ]; then
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    echo "${_BOLD}${_WHITE}| START: Homebrew upgrade      |${_RESET}"
    echo "${_BOLD}${_WHITE}| brew upgrade                 |${_RESET}"
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    brew upgrade
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    echo "${_BOLD}${_WHITE}| START: Homebrew upgrade cask |${_RESET}"
    echo "${_BOLD}${_WHITE}| brew update --cask           |${_RESET}"
    echo "${_BOLD}${_WHITE}--------------------------------${_RESET}"
    brew upgrade --cask
  else
    echo "${_BOLD}${_WHITE}-------------------------------${_RESET}"
    echo "${_BOLD}${_RED}could not upgrade due to update error${_RESET}"
  fi
}

# mov to gif
function video_to_gif() {
  if ! [ -x "$(command -v ffmpeg)" ]; then
    echo 'Error: ffmpeg is not installed. please install with (brew install ffmpeg)' >&2
    exit 1
  fi

  if ! [ -x "$(command -v gifsicle)" ]; then
    echo 'Error: gifsicle is not installed. please install with (brew install gifsicle)' >&2
    exit 1
  fi

  ffmpeg -i "$1" -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=8 > ~/Downloads/"$1".gif
}

##############################################################

## load private, non-tracked, functions
# shellcheck source=/dev/null
if [ -f "$HOME"/.functions_priv ]; then source "$HOME"/.functions_priv; fi
